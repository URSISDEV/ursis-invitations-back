ğŸ¯ FLUJO COMPLETO â€“ DE ELEGIR TEMPLATE â†’ RENDER FINAL

Te lo separo en:

UX del usuario

QuÃ© hace el FRONT

QuÃ© hace el BACK

Esto es EXACTAMENTE como debe funcionar.

ğŸŸ¦ 1) EL USUARIO ENTRA Y ELIGE UNA PLANTILLA

Ejemplo: â€œPlantilla XV â€“ Romanticâ€

ğŸ§‘â€ğŸ’» Usuario

Ve una galerÃ­a de plantillas.

Hace click en â€œUsar esta plantillaâ€.

ğŸŒ Front

El front carga el JSON del template base desde /public/templates.

Ejemplo de template base:

{
  "templateId": "xv-romantic",
  "defaultSections": ["hero_v1", "details_v1", "gallery_v1", "rsvp_basic"],
  "sectionsData": {
    "hero": {
      "title": "Mis XV",
      "subtitle": "Â¡Un dÃ­a especial!",
      "backgroundImage": "default.jpg"
    },
    "details": {
      "venue": "",
      "address": "",
      "dressCode": ""
    },
    "rsvp": {
      "enabled": true,
      "deadline": "",
      "phone": ""
    }
  }
}


El front crea un estado inicial:

const invitationDraft = {
  templateId: "xv-romantic",
  slug: "",
  eventDate: null,
  eventTime: null,
  sectionsUsed: {
    hero: "hero_v1",
    details: "details_v1",
    gallery: "gallery_v1",
    rsvp: "rsvp_basic"
  },
  sectionsOrder: ["hero_v1", "details_v1", "gallery_v1", "rsvp_basic"],
  sectionsData: { ...template.sectionsData }
};


âœ” Nada se guarda en el backend todavÃ­a.
âœ” Esto estÃ¡ sÃ³lo en el front.

ğŸ—„ï¸ Back

TodavÃ­a NADA.
El back no se usa hasta que el usuario guarda.

ğŸŸª 2) EL USUARIO COMPLETA EL WIZARD (datos del evento)
ğŸ§‘â€ğŸ’» Usuario

Completa pantallas tipo:

Nombre del evento

Fecha

Hora

DirecciÃ³n

Nombre de la quinceaÃ±era

TelÃ©fono RSVP

ğŸŒ Front

Cada que completa un paso del wizard, se actualiza el invitationDraft en memoria:

invitationDraft.sectionsData.hero.title = "XV de Santino";
invitationDraft.eventDate = "2025-03-01";
invitationDraft.slug = "xv-santino";


Pero todavÃ­a NO se guarda en el backend.

ğŸ—„ï¸ Back

AÃºn nada.

ğŸŸ§ 3) EL USUARIO QUIERE CAMBIAR UNA SECCIÃ“N

Ejemplo:
"Este Hero no me convenceâ€¦ quiero usar hero_v2"

ğŸ§‘â€ğŸ’» Usuario

Desde el builder elige:

Cambiar secciÃ³n â†’ Hero v2

ğŸŒ Front

El front hace:

Cambia sectionsUsed.hero:

invitationDraft.sectionsUsed.hero = "hero_v2";


Cambia sectionsOrder (si hace falta):

invitationDraft.sectionsOrder[0] = "hero_v2";


Mantiene la DATA del hero:

Si ambas comparten la misma estructura, sigue igual:

invitationDraft.sectionsData.hero = {
  title: "XV de Santino",
  backgroundImage: "custom.jpg"
};


El builder vuelve a renderizar usando:

const Component = sectionsRegistry["hero_v2"];
<Component data={invitationDraft.sectionsData.hero} />

ğŸ—„ï¸ Back

AÃºn nada.

TODAVÃA NO SE GUARDA NADA.

ğŸŸ© 4) EL USUARIO TERMINA EL WIZARD Y GUARDA

Hace click en:

âœ” â€œGenerar InvitaciÃ³nâ€
âœ” â€œGuardar y Publicarâ€

ğŸŒ Front â†’ Back

El front manda al backend un JSON COMPLETAMENTE ARMADO:

{
  "templateId": "xv-romantic",
  "slug": "xv-santino",
  "title": "XV AÃ±os de Santino",
  "eventDate": "2025-03-01",
  "eventTime": "20:00",
  "eventType": "XV AÃ±os",

  "sectionsUsed": {
    "hero": "hero_v2",
    "details": "details_v1",
    "gallery": "gallery_v1",
    "rsvp": "rsvp_basic"
  },

  "sectionsOrder": [
    "hero_v2",
    "details_v1",
    "gallery_v1",
    "rsvp_basic"
  ],

  "sectionsData": {
    "hero": {
      "title": "XV de Santino",
      "subtitle": "Celebramos juntos",
      "backgroundImage": "custom.jpg"
    },
    "details": {
      "venue": "Salon Azul",
      "address": "Av Libertador 1000",
      "dressCode": "Elegante"
    },
    "gallery": { "images": [] },
    "rsvp": { "enabled": true, "phone": "123" }
  }
}

ğŸ—„ï¸ Back

El backend guarda TODO en una sola entidad Invitation:

Campo	Tipo	Contenido
templateId	string	"xv-romantic"
slug	string	"xv-santino"
sectionsUsed	JSONB	IDs de secciones
sectionsOrder	JSONB	orden de las secciones
sectionsData	JSONB	todos los textos e imÃ¡genes

El back NO tiene que saber cÃ³mo funciona hero_v2, hero_v3, etc.

ğŸŸ¦ 5) EL USUARIO COMPARTE LA URL FINAL

URL dinÃ¡mica:

invia.com.ar/invitations/xv-santino

ğŸŒ Front

Tu archivo:

pages/invitations/[slug].tsx


Hace:

Fetch al backend: GET /invitations/xv-santino

El back devuelve la invitaciÃ³n con TODA la data.

El front hace:

invitation.sectionsOrder.map(sectionId => {
  const Component = sectionsRegistry[sectionId];
  const base = sectionId.split("_")[0]; 
  const data = invitation.sectionsData[base];
  return <Component key={sectionId} data={data} />;
});


ğŸŸ© Se renderiza hero_v2
ğŸŸ© Se renderiza details_v1
ğŸŸ© Se renderiza gallery_v1
ğŸŸ© Se renderiza rsvp_basic

Â¡Listo!

ğŸŸ§ 6) Â¿Y si despuÃ©s cambia una secciÃ³n?

Ejemplo:

"Ahora quiero hero_v3"

El usuario entra al builder â†’ cambia â†’ guarda.
Se actualiza solo:

sectionsUsed.hero = "hero_v3"
sectionsOrder[0] = "hero_v3"


El usuario recarga la invitaciÃ³n
â†’ Aparece otro Hero distinto, con la misma data.

ğŸŸ© RESUMEN FINAL (ULTRA CLARO)
ğŸ”µ Front

carga template base

hace wizard

permite cambiar secciones (hero_v1 â†’ hero_v2)

renderiza segÃºn sectionsRegistry

manda un JSON final al backend

ğŸ”´ Back

guarda JSONB con:

sectionsUsed

sectionsOrder

sectionsData

no tiene lÃ³gica de templates

no sabe cÃ³mo se llama hero_v2 por dentro

ğŸŸ£ InvitaciÃ³n pÃºblica

Next.js recupera el invite

recorre sectionsOrder

renderiza cada secciÃ³n segÃºn sectionId
â†’ usando el registro del front